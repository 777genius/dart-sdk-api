import{_ as r,C as l,o as p,c as d,j as s,a,E as t,ag as n}from"./chunks/framework.Cma4Z3Bd.js";const w=JSON.parse('{"title":"SceneBuilder","description":"API documentation for SceneBuilder class from dart:ui","frontmatter":{"title":"SceneBuilder","description":"API documentation for SceneBuilder class from dart:ui","category":"Classes","library":"dart:ui","outline":[2,3],"editLink":false,"prev":false,"next":false},"headers":[],"relativePath":"api/dart-ui/SceneBuilder.md","filePath":"api/dart-ui/SceneBuilder.md","lastUpdated":null}'),h={name:"api/dart-ui/SceneBuilder.md"},o={id:"scenebuilder",tabindex:"-1"},c={id:"ctor-scenebuilder",tabindex:"-1"},k={id:"prop-hashcode",tabindex:"-1"},u={id:"prop-runtimetype",tabindex:"-1"},y={id:"nosuchmethod",tabindex:"-1"},m={id:"tostring",tabindex:"-1"},g={id:"operator-equals",tabindex:"-1"};function f(E,e,b,C,F,v){const i=l("Badge");return p(),d("div",null,[s("h1",o,[e[0]||(e[0]=a("SceneBuilder ",-1)),t(i,{type:"info",text:"abstract"}),e[1]||(e[1]=a()),e[2]||(e[2]=s("a",{class:"header-anchor",href:"#scenebuilder","aria-label":'Permalink to "SceneBuilder <Badge type="info" text="abstract" />"'},"​",-1))]),e[23]||(e[23]=n('<div class="member-signature"><pre><code><span class="kw">abstract</span> <span class="kw">class</span> <span class="fn">SceneBuilder</span></code></pre></div><p>Builds a <a href="/dart-sdk-api/api/dart-ui/Scene.html">Scene</a> containing the given visuals.</p><p>A <a href="/dart-sdk-api/api/dart-ui/Scene.html">Scene</a> can then be rendered using <a href="/dart-sdk-api/api/dart-ui/FlutterView.html#render">FlutterView.render</a>.</p><p>To draw graphical operations onto a <a href="/dart-sdk-api/api/dart-ui/Scene.html">Scene</a>, first create a <a href="/dart-sdk-api/api/dart-ui/Picture.html">Picture</a> using a <a href="/dart-sdk-api/api/dart-ui/PictureRecorder.html">PictureRecorder</a> and a <a href="/dart-sdk-api/api/dart-ui/Canvas.html">Canvas</a>, and then add it to the scene using <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#addpicture">addPicture</a>.</p><h2 id="use-with-the-flutter-framework" tabindex="-1">Use with the Flutter framework <a class="header-anchor" href="#use-with-the-flutter-framework" aria-label="Permalink to &quot;Use with the Flutter framework {#use-with-the-flutter-framework}&quot;">​</a></h2><p>The Flutter framework&#39;s <code>RendererBinding</code> provides a hook for creating <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html">SceneBuilder</a> objects (<code>RendererBinding.createSceneBuilder</code>) that allows tests to hook into the scene creation logic. When creating a <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html">SceneBuilder</a> in the context of the Flutter framework, consider calling <code>RendererBinding.createSceneBuilder</code> instead of calling the <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#ctor-scenebuilder">SceneBuilder.new</a> constructor directly.</p><p>This does not apply when using the <code>dart:ui</code> API directly, without using the Flutter framework bindings, <code>flutter_test</code> framework, et al.</p><h2 id="section-constructors" tabindex="-1">Constructors <a class="header-anchor" href="#section-constructors" aria-label="Permalink to &quot;Constructors {#section-constructors}&quot;">​</a></h2>',8)),s("h3",c,[e[3]||(e[3]=a("SceneBuilder() ",-1)),t(i,{type:"tip",text:"factory"}),e[4]||(e[4]=a()),e[5]||(e[5]=s("a",{class:"header-anchor",href:"#ctor-scenebuilder","aria-label":'Permalink to "SceneBuilder() <Badge type="tip" text="factory" /> {#ctor-scenebuilder}"'},"​",-1))]),e[24]||(e[24]=n('<div class="member-signature"><pre><code><span class="kw">factory</span> <span class="fn">SceneBuilder</span>()</code></pre></div><details class="details custom-block"><summary>Implementation</summary><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">factory</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> SceneBuilder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> _NativeSceneBuilder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div></details><h2 id="section-properties" tabindex="-1">Properties <a class="header-anchor" href="#section-properties" aria-label="Permalink to &quot;Properties {#section-properties}&quot;">​</a></h2>',3)),s("h3",k,[e[6]||(e[6]=a("hashCode ",-1)),t(i,{type:"tip",text:"no setter"}),e[7]||(e[7]=a()),t(i,{type:"info",text:"inherited"}),e[8]||(e[8]=a()),e[9]||(e[9]=s("a",{class:"header-anchor",href:"#prop-hashcode","aria-label":'Permalink to "hashCode <Badge type="tip" text="no setter" /> <Badge type="info" text="inherited" /> {#prop-hashcode}"'},"​",-1))]),e[25]||(e[25]=n('<div class="member-signature"><pre><code><a href="../Dart_dart-core/int" class="type-link">int</a> <span class="kw">get</span> <span class="fn">hashCode</span></code></pre></div><p>The hash code for this object.</p><p>A hash code is a single integer which represents the state of the object that affects <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#operator-equals">operator ==</a> comparisons.</p><p>All objects have hash codes. The default hash code implemented by <a href="/dart-sdk-api/api/Dart_dart-core/Object.html">Object</a> represents only the identity of the object, the same way as the default <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#operator-equals">operator ==</a> implementation only considers objects equal if they are identical (see <a href="/dart-sdk-api/api/Dart_dart-core/identityHashCode.html">identityHashCode</a>).</p><p>If <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#operator-equals">operator ==</a> is overridden to use the object state instead, the hash code must also be changed to represent that state, otherwise the object cannot be used in hash based data structures like the default <a href="/dart-sdk-api/api/Dart_dart-core/Set.html">Set</a> and <a href="/dart-sdk-api/api/Dart_dart-core/Map.html">Map</a> implementations.</p><p>Hash codes must be the same for objects that are equal to each other according to <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#operator-equals">operator ==</a>. The hash code of an object should only change if the object changes in a way that affects equality. There are no further requirements for the hash codes. They need not be consistent between executions of the same program and there are no distribution guarantees.</p><p>Objects that are not equal are allowed to have the same hash code. It is even technically allowed that all instances have the same hash code, but if clashes happen too often, it may reduce the efficiency of hash-based data structures like <a href="/dart-sdk-api/api/Dart_dart-collection/HashSet.html">HashSet</a> or <a href="/dart-sdk-api/api/Dart_dart-collection/HashMap.html">HashMap</a>.</p><p>If a subclass overrides <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#prop-hashcode">hashCode</a>, it should override the <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#operator-equals">operator ==</a> operator as well to maintain consistency.</p><p><em>Inherited from Object.</em></p><details class="details custom-block"><summary>Implementation</summary><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> hashCode;</span></span></code></pre></div></details>',10)),s("h3",u,[e[10]||(e[10]=a("runtimeType ",-1)),t(i,{type:"tip",text:"no setter"}),e[11]||(e[11]=a()),t(i,{type:"info",text:"inherited"}),e[12]||(e[12]=a()),e[13]||(e[13]=s("a",{class:"header-anchor",href:"#prop-runtimetype","aria-label":'Permalink to "runtimeType <Badge type="tip" text="no setter" /> <Badge type="info" text="inherited" /> {#prop-runtimetype}"'},"​",-1))]),e[26]||(e[26]=n(`<div class="member-signature"><pre><code><a href="../Dart_dart-core/Type" class="type-link">Type</a> <span class="kw">get</span> <span class="fn">runtimeType</span></code></pre></div><p>A representation of the runtime type of the object.</p><p><em>Inherited from Object.</em></p><details class="details custom-block"><summary>Implementation</summary><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> runtimeType;</span></span></code></pre></div></details><h2 id="section-methods" tabindex="-1">Methods <a class="header-anchor" href="#section-methods" aria-label="Permalink to &quot;Methods {#section-methods}&quot;">​</a></h2><h3 id="addperformanceoverlay" tabindex="-1">addPerformanceOverlay() <a class="header-anchor" href="#addperformanceoverlay" aria-label="Permalink to &quot;addPerformanceOverlay() {#addperformanceoverlay}&quot;">​</a></h3><div class="member-signature"><pre><code><span class="type">void</span> <span class="fn">addPerformanceOverlay</span>(<a href="../Dart_dart-core/int" class="type-link">int</a> <span class="param">enabledOptions</span>, <a href="./Rect" class="type-link">Rect</a> <span class="param">bounds</span>)</code></pre></div><p>Adds an object to the scene that displays performance statistics.</p><p>Useful during development to assess the performance of the application. The enabledOptions controls which statistics are displayed. The bounds controls where the statistics are displayed.</p><p>enabledOptions is a bit field with the following bits defined:</p><ul><li>0x01: displayRasterizerStatistics - show raster thread frame time</li><li>0x02: visualizeRasterizerStatistics - graph raster thread frame times</li><li>0x04: displayEngineStatistics - show UI thread frame time</li><li>0x08: visualizeEngineStatistics - graph UI thread frame times Set enabledOptions to 0x0F to enable all the currently defined features.</li></ul><p>The &quot;UI thread&quot; is the thread that includes all the execution of the main Dart isolate (the isolate that can call <a href="/dart-sdk-api/api/dart-ui/FlutterView.html#render">FlutterView.render</a>). The UI thread frame time is the total time spent executing the <a href="/dart-sdk-api/api/dart-ui/PlatformDispatcher.html#prop-onbeginframe">PlatformDispatcher.onBeginFrame</a> callback. The &quot;raster thread&quot; is the thread (running on the CPU) that subsequently processes the <a href="/dart-sdk-api/api/dart-ui/Scene.html">Scene</a> provided by the Dart code to turn it into GPU commands and send it to the GPU.</p><p>See also the <code>PerformanceOverlayOption</code> enum in the rendering library. for more details.</p><details class="details custom-block"><summary>Implementation</summary><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">47</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">47</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Values</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> above must match constants </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">47</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">47</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;engine</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">47</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;src</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">47</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;sky</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">47</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;compositor</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">47</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;performance_overlay_layer.h</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> addPerformanceOverlay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> enabledOptions, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Rect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bounds);</span></span></code></pre></div></details><h3 id="addpicture" tabindex="-1">addPicture() <a class="header-anchor" href="#addpicture" aria-label="Permalink to &quot;addPicture() {#addpicture}&quot;">​</a></h3><div class="member-signature"><pre><code><span class="type">void</span> <span class="fn">addPicture</span>(
  <a href="./Offset" class="type-link">Offset</a> <span class="param">offset</span>,
  <a href="./Picture" class="type-link">Picture</a> <span class="param">picture</span>, {
  <a href="../Dart_dart-core/bool" class="type-link">bool</a> <span class="param">isComplexHint</span> = <span class="kw">false</span>,
  <a href="../Dart_dart-core/bool" class="type-link">bool</a> <span class="param">willChangeHint</span> = <span class="kw">false</span>,
})</code></pre></div><p>Adds a <a href="/dart-sdk-api/api/dart-ui/Picture.html">Picture</a> to the scene.</p><p>The picture is rasterized at the given <code>offset</code>.</p><p>The rendering <em>may</em> be cached to reduce the cost of painting the picture if it is reused in subsequent frames. Whether a picture is cached or not depends on the backend implementation. When caching is considered, the choice to cache or not cache is a heuristic based on how often the picture is being painted and the cost of painting the picture. To disable this caching, set <code>willChangeHint</code> to true. To force the caching to happen (in backends that do caching), set <code>isComplexHint</code> to true. When both are set, <code>willChangeHint</code> prevails.</p><p>In general, setting these hints is not very useful. Backends that cache pictures only do so for pictures that have been rendered three times already; setting <code>willChangeHint</code> to true to avoid caching an animating picture that changes every frame is therefore redundant, the picture wouldn&#39;t have been cached anyway. Similarly, backends that cache pictures are relatively aggressive about doing so, such that any image complicated enough to warrant caching is probably already being cached even without <code>isComplexHint</code> being set to true.</p><details class="details custom-block"><summary>Implementation</summary><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> addPicture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  Offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> offset,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  Picture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> picture, {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> isComplexHint </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> willChangeHint </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></details><h3 id="addplatformview" tabindex="-1">addPlatformView() <a class="header-anchor" href="#addplatformview" aria-label="Permalink to &quot;addPlatformView() {#addplatformview}&quot;">​</a></h3><div class="member-signature"><pre><code><span class="type">void</span> <span class="fn">addPlatformView</span>(
  <a href="../Dart_dart-core/int" class="type-link">int</a> <span class="param">viewId</span>, {
  <a href="./Offset" class="type-link">Offset</a> <span class="param">offset</span> = Offset.zero,
  <a href="../Dart_dart-core/double" class="type-link">double</a> <span class="param">width</span> = <span class="num-lit">0.0</span>,
  <a href="../Dart_dart-core/double" class="type-link">double</a> <span class="param">height</span> = <span class="num-lit">0.0</span>,
})</code></pre></div><p>Adds a platform view (e.g an iOS UIView) to the scene.</p><p>On iOS this layer splits the current output surface into two surfaces, one for the scene nodes preceding the platform view, and one for the scene nodes following the platform view.</p><h4 id="addplatformview-performance-impact" tabindex="-1">Performance impact <a class="header-anchor" href="#addplatformview-performance-impact" aria-label="Permalink to &quot;Performance impact {#addplatformview-performance-impact}&quot;">​</a></h4><p>Adding an additional surface doubles the amount of graphics memory directly used by Flutter for output buffers. Quartz might allocated extra buffers for compositing the Flutter surfaces and the platform view.</p><p>With a platform view in the scene, Quartz has to composite the two Flutter surfaces and the embedded UIView. In addition to that, on iOS versions greater than 9, the Flutter frames are synchronized with the UIView frames adding additional performance overhead.</p><p>The <code>offset</code> argument is not used for iOS and Android.</p><details class="details custom-block"><summary>Implementation</summary><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> addPlatformView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> viewId, {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  Offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> offset </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.zero,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> width </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> height </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></details><h3 id="addretained" tabindex="-1">addRetained() <a class="header-anchor" href="#addretained" aria-label="Permalink to &quot;addRetained() {#addretained}&quot;">​</a></h3><div class="member-signature"><pre><code><span class="type">void</span> <span class="fn">addRetained</span>(<a href="./EngineLayer" class="type-link">EngineLayer</a> <span class="param">retainedLayer</span>)</code></pre></div><p>Add a retained engine layer subtree from previous frames.</p><p>All the engine layers that are in the subtree of the retained layer will be automatically appended to the current engine layer tree.</p><p>Therefore, when implementing a subclass of the <code>Layer</code> concept defined in the rendering layer of Flutter&#39;s framework, once this is called, there&#39;s no need to call <code>Layer.addToScene</code> for its children layers.</p><p>Passing a layer to <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#addretained">addRetained</a> or as <code>oldLayer</code> argument to a push method counts as <em>usage</em>. A layer can be used no more than once in a scene. For example, it may not be passed simultaneously to two push methods, or to a push method and to <code>addRetained</code>.</p><p>When a layer is passed to <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#addretained">addRetained</a> all descendant layers are also considered as used in this scene. The same single-usage restriction applies to descendants.</p><p>When a layer is passed as an <code>oldLayer</code> argument to a push method, it may no longer be used in subsequent frames. If you would like to continue reusing the resources associated with the layer, store the layer object returned by the push method and use that in the next frame instead of the original object.</p><details class="details custom-block"><summary>Implementation</summary><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> addRetained</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">EngineLayer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> retainedLayer);</span></span></code></pre></div></details><h3 id="addtexture" tabindex="-1">addTexture() <a class="header-anchor" href="#addtexture" aria-label="Permalink to &quot;addTexture() {#addtexture}&quot;">​</a></h3><div class="member-signature"><pre><code><span class="type">void</span> <span class="fn">addTexture</span>(
  <a href="../Dart_dart-core/int" class="type-link">int</a> <span class="param">textureId</span>, {
  <a href="./Offset" class="type-link">Offset</a> <span class="param">offset</span> = Offset.zero,
  <a href="../Dart_dart-core/double" class="type-link">double</a> <span class="param">width</span> = <span class="num-lit">0.0</span>,
  <a href="../Dart_dart-core/double" class="type-link">double</a> <span class="param">height</span> = <span class="num-lit">0.0</span>,
  <a href="../Dart_dart-core/bool" class="type-link">bool</a> <span class="param">freeze</span> = <span class="kw">false</span>,
  <a href="./FilterQuality" class="type-link">FilterQuality</a> <span class="param">filterQuality</span> = FilterQuality.low,
})</code></pre></div><p>Adds a backend texture to the scene.</p><p>The texture is scaled to the given size and rasterized at the given offset.</p><p>If <code>freeze</code> is true the texture that is added to the scene will not be updated with new frames. <code>freeze</code> is used when resizing an embedded Android view: When resizing an Android view there is a short period during which the framework cannot tell if the newest texture frame has the previous or new size, to workaround this the framework &quot;freezes&quot; the texture just before resizing the Android view and un-freezes it when it is certain that a frame with the new size is ready.</p><details class="details custom-block"><summary>Implementation</summary><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> addTexture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> textureId, {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  Offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> offset </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.zero,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> width </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> height </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> freeze </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  FilterQuality</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> filterQuality </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> FilterQuality</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.low,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></details><h3 id="build" tabindex="-1">build() <a class="header-anchor" href="#build" aria-label="Permalink to &quot;build() {#build}&quot;">​</a></h3><div class="member-signature"><pre><code><a href="./Scene" class="type-link">Scene</a> <span class="fn">build</span>()</code></pre></div><p>Finishes building the scene.</p><p>Returns a <a href="/dart-sdk-api/api/dart-ui/Scene.html">Scene</a> containing the objects that have been added to this scene builder. The <a href="/dart-sdk-api/api/dart-ui/Scene.html">Scene</a> can then be displayed on the screen with <a href="/dart-sdk-api/api/dart-ui/FlutterView.html#render">FlutterView.render</a>.</p><p>After calling this function, the scene builder object is invalid and cannot be used further.</p><details class="details custom-block"><summary>Implementation</summary><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Scene</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> build</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div></details>`,51)),s("h3",y,[e[14]||(e[14]=a("noSuchMethod() ",-1)),t(i,{type:"info",text:"inherited"}),e[15]||(e[15]=a()),e[16]||(e[16]=s("a",{class:"header-anchor",href:"#nosuchmethod","aria-label":'Permalink to "noSuchMethod() <Badge type="info" text="inherited" /> {#nosuchmethod}"'},"​",-1))]),e[27]||(e[27]=n(`<div class="member-signature"><pre><code><span class="type">dynamic</span> <span class="fn">noSuchMethod</span>(<a href="../Dart_dart-core/Invocation" class="type-link">Invocation</a> <span class="param">invocation</span>)</code></pre></div><p>Invoked when a nonexistent method or property is accessed.</p><p>A dynamic member invocation can attempt to call a member which doesn&#39;t exist on the receiving object. Example:</p><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">dynamic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> object </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Statically allowed, run-time error</span></span></code></pre></div><p>This invalid code will invoke the <code>noSuchMethod</code> method of the integer <code>1</code> with an <a href="/dart-sdk-api/api/Dart_dart-core/Invocation.html">Invocation</a> representing the <code>.add(42)</code> call and arguments (which then throws).</p><p>Classes can override <a href="/dart-sdk-api/api/Dart_dart-core/Object.html#nosuchmethod">noSuchMethod</a> to provide custom behavior for such invalid dynamic invocations.</p><p>A class with a non-default <a href="/dart-sdk-api/api/Dart_dart-core/Object.html#nosuchmethod">noSuchMethod</a> invocation can also omit implementations for members of its interface. Example:</p><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MockList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">implements</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  noSuchMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Invocation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> invocation) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(invocation);</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">noSuchMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(invocation); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Will throw.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  MockList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>This code has no compile-time warnings or errors even though the <code>MockList</code> class has no concrete implementation of any of the <code>List</code> interface methods. Calls to <code>List</code> methods are forwarded to <code>noSuchMethod</code>, so this code will <code>log</code> an invocation similar to <a href="../Dart_dart-core/Invocation.html" class="api-link"><code>Invocation.method(#add, [42])</code></a> and then throw.</p><p>If a value is returned from <code>noSuchMethod</code>, it becomes the result of the original invocation. If the value is not of a type that can be returned by the original invocation, a type error occurs at the invocation.</p><p>The default behavior is to throw a <a href="/dart-sdk-api/api/Dart_dart-core/NoSuchMethodError.html">NoSuchMethodError</a>.</p><p><em>Inherited from Object.</em></p><details class="details custom-block"><summary>Implementation</summary><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@pragma</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;vm:entry-point&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@pragma</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;wasm:entry-point&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> dynamic</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> noSuchMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Invocation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> invocation);</span></span></code></pre></div></details><h3 id="pop" tabindex="-1">pop() <a class="header-anchor" href="#pop" aria-label="Permalink to &quot;pop() {#pop}&quot;">​</a></h3><div class="member-signature"><pre><code><span class="type">void</span> <span class="fn">pop</span>()</code></pre></div><p>Ends the effect of the most recently pushed operation.</p><p>Internally the scene builder maintains a stack of operations. Each of the operations in the stack applies to each of the objects added to the scene. Calling this function removes the most recently added operation from the stack.</p><details class="details custom-block"><summary>Implementation</summary><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> pop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div></details><h3 id="pushbackdropfilter" tabindex="-1">pushBackdropFilter() <a class="header-anchor" href="#pushbackdropfilter" aria-label="Permalink to &quot;pushBackdropFilter() {#pushbackdropfilter}&quot;">​</a></h3><div class="member-signature"><pre><code><a href="./BackdropFilterEngineLayer" class="type-link">BackdropFilterEngineLayer</a> <span class="fn">pushBackdropFilter</span>(
  <a href="./ImageFilter" class="type-link">ImageFilter</a> <span class="param">filter</span>, {
  <a href="./BlendMode" class="type-link">BlendMode</a> <span class="param">blendMode</span> = BlendMode.srcOver,
  <a href="./BackdropFilterEngineLayer" class="type-link">BackdropFilterEngineLayer</a>? <span class="param">oldLayer</span>,
  <a href="../Dart_dart-core/int" class="type-link">int</a>? <span class="param">backdropId</span>,
})</code></pre></div><p>Pushes a backdrop filter operation onto the operation stack.</p><p>The given filter is applied to the current contents of the scene as far back as the most recent save layer and rendered back to the scene using the indicated <code>blendMode</code> prior to rasterizing the child layers.</p><p>If <code>backdropId</code> is provided and not null, then this value is treated as a unique identifier for the backdrop. When the first backdrop filter with a given id is processed during rasterization, the state of the backdrop is recorded and cached. All subsequent backdrop filters with the same identifier will apply their filter to the cached backdrop. The correct usage of the backdrop id has the benefit of dramatically improving performance for applications with multiple backdrop filters. For example, an application that uses a backdrop blur filter for each item in a list view should set all filters to have the same backdrop id.</p><p>If overlapping backdrop filters use the same backdropId, then each filter will apply to the backdrop before the overlapping filter components were rendered.</p><p>If <code>oldLayer</code> is not null the engine will attempt to reuse the resources allocated for the old layer when rendering the new layer. This is purely an optimization. It has no effect on the correctness of rendering.</p><p>Passing a layer to <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#addretained">addRetained</a> or as <code>oldLayer</code> argument to a push method counts as <em>usage</em>. A layer can be used no more than once in a scene. For example, it may not be passed simultaneously to two push methods, or to a push method and to <code>addRetained</code>.</p><p>When a layer is passed to <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#addretained">addRetained</a> all descendant layers are also considered as used in this scene. The same single-usage restriction applies to descendants.</p><p>When a layer is passed as an <code>oldLayer</code> argument to a push method, it may no longer be used in subsequent frames. If you would like to continue reusing the resources associated with the layer, store the layer object returned by the push method and use that in the next frame instead of the original object.</p><p>See <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#pop">pop</a> for details about the operation stack.</p><details class="details custom-block"><summary>Implementation</summary><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">BackdropFilterEngineLayer</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> pushBackdropFilter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  ImageFilter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> filter, {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  BlendMode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> blendMode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> BlendMode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.srcOver,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  BackdropFilterEngineLayer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldLayer,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> backdropId,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></details><h3 id="pushclippath" tabindex="-1">pushClipPath() <a class="header-anchor" href="#pushclippath" aria-label="Permalink to &quot;pushClipPath() {#pushclippath}&quot;">​</a></h3><div class="member-signature"><pre><code><a href="./ClipPathEngineLayer" class="type-link">ClipPathEngineLayer</a> <span class="fn">pushClipPath</span>(
  <a href="./Path" class="type-link">Path</a> <span class="param">path</span>, {
  <a href="./Clip" class="type-link">Clip</a> <span class="param">clipBehavior</span> = Clip.antiAlias,
  <a href="./ClipPathEngineLayer" class="type-link">ClipPathEngineLayer</a>? <span class="param">oldLayer</span>,
})</code></pre></div><p>Pushes a path clip operation onto the operation stack.</p><p>Rasterization outside the given path is discarded.</p><p>If <code>oldLayer</code> is not null the engine will attempt to reuse the resources allocated for the old layer when rendering the new layer. This is purely an optimization. It has no effect on the correctness of rendering.</p><p>Passing a layer to <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#addretained">addRetained</a> or as <code>oldLayer</code> argument to a push method counts as <em>usage</em>. A layer can be used no more than once in a scene. For example, it may not be passed simultaneously to two push methods, or to a push method and to <code>addRetained</code>.</p><p>When a layer is passed to <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#addretained">addRetained</a> all descendant layers are also considered as used in this scene. The same single-usage restriction applies to descendants.</p><p>When a layer is passed as an <code>oldLayer</code> argument to a push method, it may no longer be used in subsequent frames. If you would like to continue reusing the resources associated with the layer, store the layer object returned by the push method and use that in the next frame instead of the original object.</p><p>See <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#pop">pop</a> for details about the operation stack. See <a href="/dart-sdk-api/api/dart-ui/Clip.html">Clip</a> for different clip modes. By default, the clip will be anti-aliased (clip = <a href="/dart-sdk-api/api/dart-ui/Clip.html#value-antialias">Clip.antiAlias</a>).</p><details class="details custom-block"><summary>Implementation</summary><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ClipPathEngineLayer</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> pushClipPath</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  Path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> path, {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  Clip</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> clipBehavior </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Clip</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.antiAlias,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  ClipPathEngineLayer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldLayer,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></details><h3 id="pushcliprect" tabindex="-1">pushClipRect() <a class="header-anchor" href="#pushcliprect" aria-label="Permalink to &quot;pushClipRect() {#pushcliprect}&quot;">​</a></h3><div class="member-signature"><pre><code><a href="./ClipRectEngineLayer" class="type-link">ClipRectEngineLayer</a> <span class="fn">pushClipRect</span>(
  <a href="./Rect" class="type-link">Rect</a> <span class="param">rect</span>, {
  <a href="./Clip" class="type-link">Clip</a> <span class="param">clipBehavior</span> = Clip.antiAlias,
  <a href="./ClipRectEngineLayer" class="type-link">ClipRectEngineLayer</a>? <span class="param">oldLayer</span>,
})</code></pre></div><p>Pushes a rectangular clip operation onto the operation stack.</p><p>Rasterization outside the given rectangle is discarded.</p><p>If <code>oldLayer</code> is not null the engine will attempt to reuse the resources allocated for the old layer when rendering the new layer. This is purely an optimization. It has no effect on the correctness of rendering.</p><p>Passing a layer to <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#addretained">addRetained</a> or as <code>oldLayer</code> argument to a push method counts as <em>usage</em>. A layer can be used no more than once in a scene. For example, it may not be passed simultaneously to two push methods, or to a push method and to <code>addRetained</code>.</p><p>When a layer is passed to <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#addretained">addRetained</a> all descendant layers are also considered as used in this scene. The same single-usage restriction applies to descendants.</p><p>When a layer is passed as an <code>oldLayer</code> argument to a push method, it may no longer be used in subsequent frames. If you would like to continue reusing the resources associated with the layer, store the layer object returned by the push method and use that in the next frame instead of the original object.</p><p>See <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#pop">pop</a> for details about the operation stack, and <a href="/dart-sdk-api/api/dart-ui/Clip.html">Clip</a> for different clip modes. By default, the clip will be anti-aliased (clip = <a href="/dart-sdk-api/api/dart-ui/Clip.html#value-antialias">Clip.antiAlias</a>).</p><details class="details custom-block"><summary>Implementation</summary><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ClipRectEngineLayer</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> pushClipRect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  Rect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rect, {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  Clip</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> clipBehavior </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Clip</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.antiAlias,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  ClipRectEngineLayer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldLayer,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></details><h3 id="pushcliprrect" tabindex="-1">pushClipRRect() <a class="header-anchor" href="#pushcliprrect" aria-label="Permalink to &quot;pushClipRRect() {#pushcliprrect}&quot;">​</a></h3><div class="member-signature"><pre><code><a href="./ClipRRectEngineLayer" class="type-link">ClipRRectEngineLayer</a> <span class="fn">pushClipRRect</span>(
  <a href="./RRect" class="type-link">RRect</a> <span class="param">rrect</span>, {
  <a href="./Clip" class="type-link">Clip</a> <span class="param">clipBehavior</span> = Clip.antiAlias,
  <a href="./ClipRRectEngineLayer" class="type-link">ClipRRectEngineLayer</a>? <span class="param">oldLayer</span>,
})</code></pre></div><p>Pushes a rounded-rectangular clip operation onto the operation stack.</p><p>Rasterization outside the given rounded rectangle is discarded.</p><p>If <code>oldLayer</code> is not null the engine will attempt to reuse the resources allocated for the old layer when rendering the new layer. This is purely an optimization. It has no effect on the correctness of rendering.</p><p>Passing a layer to <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#addretained">addRetained</a> or as <code>oldLayer</code> argument to a push method counts as <em>usage</em>. A layer can be used no more than once in a scene. For example, it may not be passed simultaneously to two push methods, or to a push method and to <code>addRetained</code>.</p><p>When a layer is passed to <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#addretained">addRetained</a> all descendant layers are also considered as used in this scene. The same single-usage restriction applies to descendants.</p><p>When a layer is passed as an <code>oldLayer</code> argument to a push method, it may no longer be used in subsequent frames. If you would like to continue reusing the resources associated with the layer, store the layer object returned by the push method and use that in the next frame instead of the original object.</p><p>See <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#pop">pop</a> for details about the operation stack, and <a href="/dart-sdk-api/api/dart-ui/Clip.html">Clip</a> for different clip modes. By default, the clip will be anti-aliased (clip = <a href="/dart-sdk-api/api/dart-ui/Clip.html#value-antialias">Clip.antiAlias</a>).</p><details class="details custom-block"><summary>Implementation</summary><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ClipRRectEngineLayer</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> pushClipRRect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  RRect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rrect, {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  Clip</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> clipBehavior </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Clip</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.antiAlias,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  ClipRRectEngineLayer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldLayer,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></details><h3 id="pushcliprsuperellipse" tabindex="-1">pushClipRSuperellipse() <a class="header-anchor" href="#pushcliprsuperellipse" aria-label="Permalink to &quot;pushClipRSuperellipse() {#pushcliprsuperellipse}&quot;">​</a></h3><div class="member-signature"><pre><code><a href="./ClipRSuperellipseEngineLayer" class="type-link">ClipRSuperellipseEngineLayer</a> <span class="fn">pushClipRSuperellipse</span>(
  <a href="./RSuperellipse" class="type-link">RSuperellipse</a> <span class="param">rsuperellipse</span>, {
  <a href="./Clip" class="type-link">Clip</a> <span class="param">clipBehavior</span> = Clip.antiAlias,
  <a href="./ClipRSuperellipseEngineLayer" class="type-link">ClipRSuperellipseEngineLayer</a>? <span class="param">oldLayer</span>,
})</code></pre></div><p>Pushes a rounded-superellipse clip operation onto the operation stack.</p><p>Rasterization outside the given rounded superellipse is discarded.</p><p>If <code>oldLayer</code> is not null the engine will attempt to reuse the resources allocated for the old layer when rendering the new layer. This is purely an optimization. It has no effect on the correctness of rendering.</p><p>Passing a layer to <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#addretained">addRetained</a> or as <code>oldLayer</code> argument to a push method counts as <em>usage</em>. A layer can be used no more than once in a scene. For example, it may not be passed simultaneously to two push methods, or to a push method and to <code>addRetained</code>.</p><p>When a layer is passed to <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#addretained">addRetained</a> all descendant layers are also considered as used in this scene. The same single-usage restriction applies to descendants.</p><p>When a layer is passed as an <code>oldLayer</code> argument to a push method, it may no longer be used in subsequent frames. If you would like to continue reusing the resources associated with the layer, store the layer object returned by the push method and use that in the next frame instead of the original object.</p><p>See <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#pop">pop</a> for details about the operation stack, and <a href="/dart-sdk-api/api/dart-ui/Clip.html">Clip</a> for different clip modes. By default, the clip will be anti-aliased (clip = <a href="/dart-sdk-api/api/dart-ui/Clip.html#value-antialias">Clip.antiAlias</a>).</p><details class="details custom-block"><summary>Implementation</summary><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ClipRSuperellipseEngineLayer</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> pushClipRSuperellipse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  RSuperellipse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rsuperellipse, {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  Clip</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> clipBehavior </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Clip</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.antiAlias,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  ClipRSuperellipseEngineLayer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldLayer,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></details><h3 id="pushcolorfilter" tabindex="-1">pushColorFilter() <a class="header-anchor" href="#pushcolorfilter" aria-label="Permalink to &quot;pushColorFilter() {#pushcolorfilter}&quot;">​</a></h3><div class="member-signature"><pre><code><a href="./ColorFilterEngineLayer" class="type-link">ColorFilterEngineLayer</a> <span class="fn">pushColorFilter</span>(
  <a href="./ColorFilter" class="type-link">ColorFilter</a> <span class="param">filter</span>, {
  <a href="./ColorFilterEngineLayer" class="type-link">ColorFilterEngineLayer</a>? <span class="param">oldLayer</span>,
})</code></pre></div><p>Pushes a color filter operation onto the operation stack.</p><p>The given color is applied to the objects&#39; rasterization using the given blend mode.</p><p>If <code>oldLayer</code> is not null the engine will attempt to reuse the resources allocated for the old layer when rendering the new layer. This is purely an optimization. It has no effect on the correctness of rendering.</p><p>Passing a layer to <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#addretained">addRetained</a> or as <code>oldLayer</code> argument to a push method counts as <em>usage</em>. A layer can be used no more than once in a scene. For example, it may not be passed simultaneously to two push methods, or to a push method and to <code>addRetained</code>.</p><p>When a layer is passed to <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#addretained">addRetained</a> all descendant layers are also considered as used in this scene. The same single-usage restriction applies to descendants.</p><p>When a layer is passed as an <code>oldLayer</code> argument to a push method, it may no longer be used in subsequent frames. If you would like to continue reusing the resources associated with the layer, store the layer object returned by the push method and use that in the next frame instead of the original object.</p><p>See <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#pop">pop</a> for details about the operation stack.</p><details class="details custom-block"><summary>Implementation</summary><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ColorFilterEngineLayer</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> pushColorFilter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ColorFilter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> filter, {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ColorFilterEngineLayer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldLayer});</span></span></code></pre></div></details><h3 id="pushimagefilter" tabindex="-1">pushImageFilter() <a class="header-anchor" href="#pushimagefilter" aria-label="Permalink to &quot;pushImageFilter() {#pushimagefilter}&quot;">​</a></h3><div class="member-signature"><pre><code><a href="./ImageFilterEngineLayer" class="type-link">ImageFilterEngineLayer</a> <span class="fn">pushImageFilter</span>(
  <a href="./ImageFilter" class="type-link">ImageFilter</a> <span class="param">filter</span>, {
  <a href="./Offset" class="type-link">Offset</a> <span class="param">offset</span> = Offset.zero,
  <a href="./ImageFilterEngineLayer" class="type-link">ImageFilterEngineLayer</a>? <span class="param">oldLayer</span>,
})</code></pre></div><p>Pushes an image filter operation onto the operation stack.</p><p>The given filter is applied to the children&#39;s rasterization before compositing them into the scene.</p><p>If <code>oldLayer</code> is not null the engine will attempt to reuse the resources allocated for the old layer when rendering the new layer. This is purely an optimization. It has no effect on the correctness of rendering.</p><p>Passing a layer to <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#addretained">addRetained</a> or as <code>oldLayer</code> argument to a push method counts as <em>usage</em>. A layer can be used no more than once in a scene. For example, it may not be passed simultaneously to two push methods, or to a push method and to <code>addRetained</code>.</p><p>When a layer is passed to <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#addretained">addRetained</a> all descendant layers are also considered as used in this scene. The same single-usage restriction applies to descendants.</p><p>When a layer is passed as an <code>oldLayer</code> argument to a push method, it may no longer be used in subsequent frames. If you would like to continue reusing the resources associated with the layer, store the layer object returned by the push method and use that in the next frame instead of the original object.</p><p>See <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#pop">pop</a> for details about the operation stack.</p><details class="details custom-block"><summary>Implementation</summary><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ImageFilterEngineLayer</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> pushImageFilter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  ImageFilter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> filter, {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  Offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> offset </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.zero,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  ImageFilterEngineLayer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldLayer,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></details><h3 id="pushoffset" tabindex="-1">pushOffset() <a class="header-anchor" href="#pushoffset" aria-label="Permalink to &quot;pushOffset() {#pushoffset}&quot;">​</a></h3><div class="member-signature"><pre><code><a href="./OffsetEngineLayer" class="type-link">OffsetEngineLayer</a> <span class="fn">pushOffset</span>(
  <a href="../Dart_dart-core/double" class="type-link">double</a> <span class="param">dx</span>,
  <a href="../Dart_dart-core/double" class="type-link">double</a> <span class="param">dy</span>, {
  <a href="./OffsetEngineLayer" class="type-link">OffsetEngineLayer</a>? <span class="param">oldLayer</span>,
})</code></pre></div><p>Pushes an offset operation onto the operation stack.</p><p>This is equivalent to <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#pushtransform">pushTransform</a> with a matrix with only translation.</p><p>If <code>oldLayer</code> is not null the engine will attempt to reuse the resources allocated for the old layer when rendering the new layer. This is purely an optimization. It has no effect on the correctness of rendering.</p><p>Passing a layer to <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#addretained">addRetained</a> or as <code>oldLayer</code> argument to a push method counts as <em>usage</em>. A layer can be used no more than once in a scene. For example, it may not be passed simultaneously to two push methods, or to a push method and to <code>addRetained</code>.</p><p>When a layer is passed to <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#addretained">addRetained</a> all descendant layers are also considered as used in this scene. The same single-usage restriction applies to descendants.</p><p>When a layer is passed as an <code>oldLayer</code> argument to a push method, it may no longer be used in subsequent frames. If you would like to continue reusing the resources associated with the layer, store the layer object returned by the push method and use that in the next frame instead of the original object.</p><p>See <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#pop">pop</a> for details about the operation stack.</p><details class="details custom-block"><summary>Implementation</summary><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">OffsetEngineLayer</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> pushOffset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dx, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dy, {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">OffsetEngineLayer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldLayer});</span></span></code></pre></div></details><h3 id="pushopacity" tabindex="-1">pushOpacity() <a class="header-anchor" href="#pushopacity" aria-label="Permalink to &quot;pushOpacity() {#pushopacity}&quot;">​</a></h3><div class="member-signature"><pre><code><a href="./OpacityEngineLayer" class="type-link">OpacityEngineLayer</a> <span class="fn">pushOpacity</span>(
  <a href="../Dart_dart-core/int" class="type-link">int</a> <span class="param">alpha</span>, {
  <a href="./Offset" class="type-link">Offset</a>? <span class="param">offset</span> = Offset.zero,
  <a href="./OpacityEngineLayer" class="type-link">OpacityEngineLayer</a>? <span class="param">oldLayer</span>,
})</code></pre></div><p>Pushes an opacity operation onto the operation stack.</p><p>The given alpha value is blended into the alpha value of the objects&#39; rasterization. An alpha value of 0 makes the objects entirely invisible. An alpha value of 255 has no effect (i.e., the objects retain the current opacity).</p><p>If <code>oldLayer</code> is not null the engine will attempt to reuse the resources allocated for the old layer when rendering the new layer. This is purely an optimization. It has no effect on the correctness of rendering.</p><p>Passing a layer to <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#addretained">addRetained</a> or as <code>oldLayer</code> argument to a push method counts as <em>usage</em>. A layer can be used no more than once in a scene. For example, it may not be passed simultaneously to two push methods, or to a push method and to <code>addRetained</code>.</p><p>When a layer is passed to <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#addretained">addRetained</a> all descendant layers are also considered as used in this scene. The same single-usage restriction applies to descendants.</p><p>When a layer is passed as an <code>oldLayer</code> argument to a push method, it may no longer be used in subsequent frames. If you would like to continue reusing the resources associated with the layer, store the layer object returned by the push method and use that in the next frame instead of the original object.</p><p>See <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#pop">pop</a> for details about the operation stack.</p><details class="details custom-block"><summary>Implementation</summary><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">OpacityEngineLayer</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> pushOpacity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> alpha, {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  Offset</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> offset </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.zero,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  OpacityEngineLayer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldLayer,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></details><h3 id="pushshadermask" tabindex="-1">pushShaderMask() <a class="header-anchor" href="#pushshadermask" aria-label="Permalink to &quot;pushShaderMask() {#pushshadermask}&quot;">​</a></h3><div class="member-signature"><pre><code><a href="./ShaderMaskEngineLayer" class="type-link">ShaderMaskEngineLayer</a> <span class="fn">pushShaderMask</span>(
  <a href="./Shader" class="type-link">Shader</a> <span class="param">shader</span>,
  <a href="./Rect" class="type-link">Rect</a> <span class="param">maskRect</span>,
  <a href="./BlendMode" class="type-link">BlendMode</a> <span class="param">blendMode</span>, {
  <a href="./ShaderMaskEngineLayer" class="type-link">ShaderMaskEngineLayer</a>? <span class="param">oldLayer</span>,
  <a href="./FilterQuality" class="type-link">FilterQuality</a> <span class="param">filterQuality</span> = FilterQuality.low,
})</code></pre></div><p>Pushes a shader mask operation onto the operation stack.</p><p>The given shader is applied to the object&#39;s rasterization in the given rectangle using the given blend mode.</p><p>If <code>oldLayer</code> is not null the engine will attempt to reuse the resources allocated for the old layer when rendering the new layer. This is purely an optimization. It has no effect on the correctness of rendering.</p><p>Passing a layer to <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#addretained">addRetained</a> or as <code>oldLayer</code> argument to a push method counts as <em>usage</em>. A layer can be used no more than once in a scene. For example, it may not be passed simultaneously to two push methods, or to a push method and to <code>addRetained</code>.</p><p>When a layer is passed to <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#addretained">addRetained</a> all descendant layers are also considered as used in this scene. The same single-usage restriction applies to descendants.</p><p>When a layer is passed as an <code>oldLayer</code> argument to a push method, it may no longer be used in subsequent frames. If you would like to continue reusing the resources associated with the layer, store the layer object returned by the push method and use that in the next frame instead of the original object.</p><p>See <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#pop">pop</a> for details about the operation stack.</p><details class="details custom-block"><summary>Implementation</summary><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ShaderMaskEngineLayer</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> pushShaderMask</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  Shader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> shader,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  Rect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> maskRect,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  BlendMode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> blendMode, {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  ShaderMaskEngineLayer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldLayer,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  FilterQuality</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> filterQuality </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> FilterQuality</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.low,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></details><h3 id="pushtransform" tabindex="-1">pushTransform() <a class="header-anchor" href="#pushtransform" aria-label="Permalink to &quot;pushTransform() {#pushtransform}&quot;">​</a></h3><div class="member-signature"><pre><code><a href="./TransformEngineLayer" class="type-link">TransformEngineLayer</a> <span class="fn">pushTransform</span>(
  <a href="../Dart_dart-typed_data/Float64List" class="type-link">Float64List</a> <span class="param">matrix4</span>, {
  <a href="./TransformEngineLayer" class="type-link">TransformEngineLayer</a>? <span class="param">oldLayer</span>,
})</code></pre></div><p>Pushes a transform operation onto the operation stack.</p><p>The objects are transformed by the given matrix before rasterization.</p><p>If <code>oldLayer</code> is not null the engine will attempt to reuse the resources allocated for the old layer when rendering the new layer. This is purely an optimization. It has no effect on the correctness of rendering.</p><p>Passing a layer to <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#addretained">addRetained</a> or as <code>oldLayer</code> argument to a push method counts as <em>usage</em>. A layer can be used no more than once in a scene. For example, it may not be passed simultaneously to two push methods, or to a push method and to <code>addRetained</code>.</p><p>When a layer is passed to <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#addretained">addRetained</a> all descendant layers are also considered as used in this scene. The same single-usage restriction applies to descendants.</p><p>When a layer is passed as an <code>oldLayer</code> argument to a push method, it may no longer be used in subsequent frames. If you would like to continue reusing the resources associated with the layer, store the layer object returned by the push method and use that in the next frame instead of the original object.</p><p>See <a href="/dart-sdk-api/api/dart-ui/SceneBuilder.html#pop">pop</a> for details about the operation stack.</p><details class="details custom-block"><summary>Implementation</summary><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TransformEngineLayer</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> pushTransform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float64List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> matrix4, {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TransformEngineLayer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldLayer});</span></span></code></pre></div></details>`,130)),s("h3",m,[e[17]||(e[17]=a("toString() ",-1)),t(i,{type:"info",text:"inherited"}),e[18]||(e[18]=a()),e[19]||(e[19]=s("a",{class:"header-anchor",href:"#tostring","aria-label":'Permalink to "toString() <Badge type="info" text="inherited" /> {#tostring}"'},"​",-1))]),e[28]||(e[28]=n('<div class="member-signature"><pre><code><a href="../Dart_dart-core/String" class="type-link">String</a> <span class="fn">toString</span>()</code></pre></div><p>A string representation of this object.</p><p>Some classes have a default textual representation, often paired with a static <code>parse</code> function (like <a href="/dart-sdk-api/api/Dart_dart-core/int.html#parse">int.parse</a>). These classes will provide the textual representation as their string representation.</p><p>Other classes have no meaningful textual representation that a program will care about. Such classes will typically override <code>toString</code> to provide useful information when inspecting the object, mainly for debugging or logging.</p><p><em>Inherited from Object.</em></p><details class="details custom-block"><summary>Implementation</summary><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> String</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div></details><h2 id="section-operators" tabindex="-1">Operators <a class="header-anchor" href="#section-operators" aria-label="Permalink to &quot;Operators {#section-operators}&quot;">​</a></h2>',7)),s("h3",g,[e[20]||(e[20]=a("operator ==() ",-1)),t(i,{type:"info",text:"inherited"}),e[21]||(e[21]=a()),e[22]||(e[22]=s("a",{class:"header-anchor",href:"#operator-equals","aria-label":'Permalink to "operator ==() <Badge type="info" text="inherited" /> {#operator-equals}"'},"​",-1))]),e[29]||(e[29]=n('<div class="member-signature"><pre><code><a href="../Dart_dart-core/bool" class="type-link">bool</a> <span class="fn">operator ==</span>(<a href="../Dart_dart-core/Object" class="type-link">Object</a> <span class="param">other</span>)</code></pre></div><p>The equality operator.</p><p>The default behavior for all <a href="/dart-sdk-api/api/Dart_dart-core/Object.html">Object</a>s is to return true if and only if this object and <code>other</code> are the same object.</p><p>Override this method to specify a different equality relation on a class. The overriding method must still be an equivalence relation. That is, it must be:</p><ul><li><p>Total: It must return a boolean for all arguments. It should never throw.</p></li><li><p>Reflexive: For all objects <code>o</code>, <code>o == o</code> must be true.</p></li><li><p>Symmetric: For all objects <code>o1</code> and <code>o2</code>, <code>o1 == o2</code> and <code>o2 == o1</code> must either both be true, or both be false.</p></li><li><p>Transitive: For all objects <code>o1</code>, <code>o2</code>, and <code>o3</code>, if <code>o1 == o2</code> and <code>o2 == o3</code> are true, then <code>o1 == o3</code> must be true.</p></li></ul><p>The method should also be consistent over time, so whether two objects are equal should only change if at least one of the objects was modified.</p><p>If a subclass overrides the equality operator, it should override the <a href="/dart-sdk-api/api/Dart_dart-core/Object.html#prop-hashcode">hashCode</a> method as well to maintain consistency.</p><p><em>Inherited from Object.</em></p><details class="details custom-block"><summary>Implementation</summary><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> bool</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> operator</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> other);</span></span></code></pre></div></details>',9))])}const S=r(h,[["render",f]]);export{w as __pageData,S as default};

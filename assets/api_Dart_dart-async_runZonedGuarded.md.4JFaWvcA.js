import{_ as a,o as r,c as n,ag as o}from"./chunks/framework.BHT9daFK.js";const h=JSON.parse('{"title":"runZonedGuarded function","description":"API documentation for the runZonedGuarded<R> function from dart:async","frontmatter":{"title":"runZonedGuarded<R> function","description":"API documentation for the runZonedGuarded<R> function from dart:async","category":"Functions","library":"dart:async","outline":false,"editLink":false,"prev":false,"next":false},"headers":[],"relativePath":"api/Dart_dart-async/runZonedGuarded.md","filePath":"api/Dart_dart-async/runZonedGuarded.md"}'),t={name:"api/Dart_dart-async/runZonedGuarded.md"};function s(d,e,c,i,p,l){return r(),n("div",null,[...e[0]||(e[0]=[o(`<h1 id="runzonedguarded-r" tabindex="-1">runZonedGuarded&lt;R&gt; <a class="header-anchor" href="#runzonedguarded-r" aria-label="Permalink to &quot;runZonedGuarded\\&lt;R\\&gt;&quot;">â€‹</a></h1><div class="member-signature"><pre><code><span class="type">R</span>? <span class="fn">runZonedGuarded&lt;R&gt;</span>(
  <span class="type">R</span> <span class="type">Function</span>() <span class="param">body</span>,
  <span class="type">void</span> <span class="type">Function</span>(<a href="../Dart_dart-core/Object" class="type-link">Object</a> <span class="param">error</span>, <a href="../Dart_dart-core/StackTrace" class="type-link">StackTrace</a> <span class="param">stack</span>) <span class="param">onError</span>, {
  <a href="../Dart_dart-core/Map" class="type-link">Map</a>&lt;<a href="../Dart_dart-core/Object" class="type-link">Object</a>?, <a href="../Dart_dart-core/Object" class="type-link">Object</a>?&gt;? <span class="param">zoneValues</span>,
  <a href="./ZoneSpecification" class="type-link">ZoneSpecification</a>? <span class="param">zoneSpecification</span>,
})</code></pre></div><p>Runs <code>body</code> in its own error zone.</p><p>Creates a new zone using <a href="/dart-sdk-api/api/Dart_dart-async/Zone.html#fork">Zone.fork</a> based on <code>zoneSpecification</code> and <code>zoneValues</code>, then runs <code>body</code> in that zone and returns the result.</p><p>The <code>onError</code> function is used <em>both</em> to handle asynchronous errors by overriding <a href="/dart-sdk-api/api/Dart_dart-async/ZoneSpecification.html#prop-handleuncaughterror">ZoneSpecification.handleUncaughtError</a> in <code>zoneSpecification</code>, if any, <em>and</em> to handle errors thrown synchronously by the call to <code>body</code>.</p><p>If an error occurs synchronously in <code>body</code>, then throwing in the <code>onError</code> handler makes the call to <code>runZonedGuarded</code> throw that error, and otherwise the call to <code>runZonedGuarded</code> returns <code>null</code>.</p><p>The created zone will always be an <em>error zone</em>. Asynchronous errors in futures never cross zone boundaries between zones with a different <a href="/dart-sdk-api/api/Dart_dart-async/Zone.html#prop-errorzone">Zone.errorZone</a>. A consequence of that behavior can be that a <a href="/dart-sdk-api/api/Dart_dart-async/Future.html">Future</a> which completes as an error in the created zone will seem to never complete when used from a zone that belongs to a different error zone. Multiple attempts to use the future in a zone where the error is inaccessible will cause the error to be reported <em>again</em> in it&#39;s original error zone.</p>`,7)])])}const f=a(t,[["render",s]]);export{h as __pageData,f as default};
